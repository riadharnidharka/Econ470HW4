# Preliminaries -----------------------------------------------------------
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, ggplot2, dplyr, lubridate, stringr, readxl, data.table, gdata)

#Question 1
final.data<- read_rds("data/output/final_ma_data.rds")

library(dplyr)
library(ggplot2)

# Group data by county and year, and summarize plan counts
summary_data <- final.data %>%
  group_by(county, year) %>%
  summarize(planid = n())

# Create a boxplot to visualize the distribution of plan counts by county over time
question1<- ggplot(summary_data, aes(x = factor(year), y = planid)) +
  geom_boxplot() +
  labs(x = "Year", y = "Plan Counts", title = "Distribution of Plan Counts by County Over Time") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels if needed

question1

#Question 2
library(ggplot2)

# Filter the data for the years 2010, 2012, and 2015
filtered_data <- final.data %>%
  filter(year %in% c(2010, 2012, 2015))

# Count the occurrences of each star rating for each year
rating_counts <- filtered_data %>%
  group_by(year, Star_Rating) %>%
  summarise(count = n())

# Create bar graphs for each year's distribution of star ratings
question2<- ggplot(rating_counts, aes(x = factor(Star_Rating), y = count, fill = factor(year))) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~year, scales = "free") +
  labs(x = "Star Rating", y = "Count", title = "Distribution of Star Ratings Over Time") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels if needed

question2

#Question 3 

# Filter the data for years 2010 to 2015
filtered_data <- final.data %>%
  filter(year >= 2010 & year <= 2015)

# Group the data by year and calculate the average benchmark payment for each year
average_benchmark_payments <- filtered_data %>%
  group_by(year) %>%
  summarize(average_benchmark_payment = mean(ma_rate, na.rm = TRUE))

# Print or view the result
print(average_benchmark_payments)

library(ggplot2)

# Assuming average_benchmark_payments is the data frame containing average benchmark payments for each year

# Plotting the average benchmark payments over time
question3<- ggplot(average_benchmark_payments, aes(x = year, y = average_benchmark_payment)) +
  geom_line() +
  geom_point() +
  labs(title = "Average Benchmark Payment Over Time (2010-2015)",
       x = "Year",
       y = "Average Benchmark Payment") +
  theme_minimal()

question3

#Question 4
ma.penetration<- read_rds("data/output/ma_penetration.rds")
ffs.costs<- read_rds("data/output/ffs_costs.rds")

enrollment_summary <- ffs.costs %>%
  group_by(year) %>%
  summarize(total_parta_enroll = sum(parta_enroll, na.rm = TRUE))

# Print or view the enrollment summary
print(enrollment_summary)

ma_eligibles <- ma.penetration %>%
  group_by(year) %>%
  summarize(ma_eligibles = sum(avg_eligibles, na.rm = TRUE))

# Print or view the result
print(ma_eligibles)

# Join the enrollment summary with MA eligibles data by year
total_eligibles <- enrollment_summary %>%
  left_join(ma_eligibles, by = "year") %>%
  # Calculate total Medicare eligibles by adding MA eligibles and total Part A enrollments
  mutate(total_medicare_eligibles = ma_eligibles + total_parta_enroll)

# Print or view the result
print(total_eligibles)

# Assuming your data spans from 2010 through 2015, you can filter the total_eligibles dataframe accordingly
filtered_data <- total_eligibles %>%
  filter(year >= 2010 & year <= 2015)

# Calculate the average share of Medicare Advantage relative to all Medicare eligibles
filtered_data <- filtered_data %>%
  mutate(average_ma_share = ma_eligibles / total_medicare_eligibles)

# Plot the data
question4<- ggplot(filtered_data, aes(x = year, y = average_ma_share)) +
  geom_line() +
  geom_point() +
  labs(x = "Year", y = "Average Share of Medicare Advantage", title = "Average Share of Medicare Advantage Over Time (2010-2015)")

question4

#Question5

ma.data <- read_rds("data/output/final_ma_data.rds")
ma.data.clean <- ma.data %>%
  filter(!is.na(avg_enrollment) & year==2010 & !is.na(partc_score)) 

ma.data.clean <- ma.data.clean %>%
  mutate(raw_rating=rowMeans(
    cbind(breastcancer_screen,rectalcancer_screen,cv_cholscreen,
          glaucoma_test,monitoring,flu_vaccine,pn_vaccine,physical_health,
          mental_health,osteo_test,physical_monitor,primaryaccess
          ,nodelays,carequickly,
          overallrating_care,overallrating_plan,
          doctor_communicate,customer_service,osteo_manage,
          diabetes_eye,diabetes_kidney,diabetes_bloodsugar,
          diabetes_chol,bloodpressure,ra_manage,
          copd_test,bladder,falling,appeals_timely,
          appeals_review),
    na.rm=T)) %>%
  select(contractid, planid, fips, avg_enrollment, state, county, raw_rating, partc_score,
         avg_eligibles, avg_enrolled, premium_partc, risk_ab, Star_Rating,
         bid, avg_ffscost, ma_rate)

# Round the running variable to the nearest 0.5 to determine the star rating
ma.data.clean <- ma.data.clean %>%
  mutate(star_rating = round(raw_rating * 2) / 2)

# Count the number of plans in each star rating category
star_rating_counts <- ma.data.clean %>%
  group_by(star_rating) %>%
  summarize(number_of_plans = n())

# Print or view the table
print(star_rating_counts)

#Question 6
# Create ma.rd1 with required mutations
ma.rd1 <- ma.data.clean %>%
  mutate(score = raw_rating - 2.25,
         treat = (score >= 0),
         window1 = (score >= -0.175 & score <= 0.175),
         window2 = (score >= -0.125 & score <= 0.125),
         mkt_share = avg_enrollment / avg_eligibles,
         ln_share = log(mkt_share),
         score_treat = score * treat)

# Estimate treatment effect for 2.5 stars
star25.1 <- lm(mkt_share ~ score + treat, data = ma.rd1)
star25.2 <- lm(mkt_share ~ score + treat, data = subset(ma.rd1, window1 == TRUE))
star25.3 <- lm(mkt_share ~ score + treat + score_treat, data = subset(ma.rd1, window1 == TRUE))
star25.4 <- lm(mkt_share ~ score + treat + score_treat, data = subset(ma.rd1, window2 == TRUE))

# Estimate treatment effect for 3 stars
star3.1 <- lm(mkt_share ~ score + treat, data = ma.rd1)
star3.2 <- lm(mkt_share ~ score + treat, data = subset(ma.rd1, window1 == TRUE))
star3.3 <- lm(mkt_share ~ score + treat + score_treat, data = subset(ma.rd1, window1 == TRUE))
star3.4 <- lm(mkt_share ~ score + treat + score_treat, data = subset(ma.rd1, window2 == TRUE))

# Estimate treatment effect for 3.5 stars
star35.1 <- lm(mkt_share ~ score + treat, data = ma.rd1)
star35.2 <- lm(mkt_share ~ score + treat, data = subset(ma.rd1, window1 == TRUE))
star35.3 <- lm(mkt_share ~ score + treat + score_treat, data = subset(ma.rd1, window1 == TRUE))
star35.4 <- lm(mkt_share ~ score + treat + score_treat, data = subset(ma.rd1, window2 == TRUE))

# Extract coefficients
est25_1 <- as.numeric(star25.1$coef[3])
est25_2 <- as.numeric(star25.2$coef[3])
est25_3 <- as.numeric(star25.3$coef[3])
est25_4 <- as.numeric(star25.4$coef[3])

est3_1 <- as.numeric(star3.1$coef[3])
est3_2 <- as.numeric(star3.2$coef[3])
est3_3 <- as.numeric(star3.3$coef[3])
est3_4 <- as.numeric(star3.4$coef[3])

est35_1 <- as.numeric(star35.1$coef[3])
est35_2 <- as.numeric(star35.2$coef[3])
est35_3 <- as.numeric(star35.3$coef[3])
est35_4 <- as.numeric(star35.4$coef[3])

# Create summary table
# Create a list of models
models <- list(star25.1, star25.2, star25.3, star25.4, 
               star3.1, star3.2, star3.3, star3.4, 
               star35.1, star35.2, star35.3, star35.4)

# Extract coefficients and other information
coefficients <- sapply(models, function(model) as.numeric(model$coef[3]))
r_squared <- sapply(models, function(model) summary(model)$r.squared)
nobs <- sapply(models, function(model) summary(model)$nobs)

# Create the summary table
summary_table <- data.frame(
  term = c("Bandwidth", "R-squared", "Number of Observations"),
  m1 = c("0.25", NA, NA),
  m2 = c("0.175", NA, NA),
  m3 = c("0.175", NA, NA),
  m4 = c("0.125", NA, NA)
)

# Add coefficients and R-squared values to the summary table
for (i in seq_along(models)) {
  summary_table[paste0("m", i + 4)] <- c(coefficients[i], r_squared[i], nobs[i])
}

# Print the summary table
print(summary_table)


#Question 7
# Initialize lists to store results
results_3 <- list()
results_35 <- list()

# Loop through each bandwidth value
bandwidths <- c(0.1, 0.12, 0.13, 0.14, 0.15)

for (bw in bandwidths) {
  # Filter data for the specific bandwidth
  ma.rd1_bw <- ma.rd1 %>%
    mutate(window3 = (score >= (3 - bw) & score <= (3 + bw)),
           window35 = (score >= (3.5 - bw) & score <= (3.5 + bw)))
  
  # Fit linear regression models
  star3_lm <- lm(mkt_share ~ score + treat + score_treat, data = ma.rd1_bw %>% filter(window3))
  star35_lm <- lm(mkt_share ~ score + treat + score_treat, data = ma.rd1_bw %>% filter(window35))
  
  # Store coefficient estimates
  results_3[[as.character(bw)]] <- as.numeric(star3_lm$coef[4])  # Coefficient for score_treat
  results_35[[as.character(bw)]] <- as.numeric(star35_lm$coef[4])  # Coefficient for score_treat
}

# Combine results into data frames
results_df_3 <- data.frame(Bandwidth = bandwidths, Estimate = unlist(results_3))
results_df_35 <- data.frame(Bandwidth = bandwidths, Estimate = unlist(results_35))

# Plot results
plot(results_df_3$Bandwidth, results_df_3$Estimate, type = "l", col = "blue",
     ylim = range(c(results_df_3$Estimate, results_df_35$Estimate)),
     xlab = "Bandwidth", ylab = "Effect on Enrollment",
     main = "Effect of 3-Star Rating on Enrollment by Bandwidth")
lines(results_df_35$Bandwidth, results_df_35$Estimate, type = "l", col = "red")
legend("topright", legend = c("3-Star", "3.5-Star"), col = c("blue", "red"), lty = 1)



